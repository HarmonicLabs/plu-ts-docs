---
sidebar_position: 1
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Vesting

Now that we are a bit more familiar on how to interact properly with a smart contract,
let's do a step forward and see if we can come up with a slightly more complex contract.

The final result can be found at [`HarmonicLabs/vesting-pluts`](https://github.com/HarmonicLabs/vesting-pluts).

:::info
Check `package.json` file at [`HarmonicLabs/vesting-pluts`](https://github.com/HarmonicLabs/vesting-pluts/blob/main/package.json) for versions of packages used lately.
:::

## Project set up

We will once again start from the [`plu-ts-starter`](https://github.com/HarmonicLabs/plu-ts-starter) template (with the plu-ts version ~0.9.0) :
```bash
git clone https://github.com/HarmonicLabs/plu-ts-starter.git
mv plu-ts-starter vesting-pluts
cd vesting-pluts
git remote remove origin
```

This gives us a simple project structure:
```
./vesting-pluts
â”œâ”€â”€ package.json
â”œâ”€â”€ package-lock.json
â”œâ”€â”€ Introduction
â”œâ”€â”€ src
â”‚   â”œâ”€â”€ contract.ts
â”‚   â”œâ”€â”€ index.ts
â”‚   â”œâ”€â”€ MyDatum
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â””â”€â”€ MyRedeemer
â”‚       â””â”€â”€ index.ts
â””â”€â”€ tsconfig.json
```

## Add dependencies

Just like the [Hello plu-ts](./Hello_World.mdx) example; this project already comes with plu-ts as dependency;
all we need to do to then is to run

```
npm install
```

This time instead of working with Browser wallets, we will generate key pairs using [Web Crypto API](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/generateKey) and thus generate address.
We will also be making use of [Blockfrost API](https://blockfrost.io/) to interact with the contract, address, transaction on/to-be-on chain (enabled with the package `@harmoniclabs/blockfrost-pluts`)
Along with Blockfrost, we will also be making use of [Plu-ts Emulator](https://github.com/HarmonicLabs/pluts-emulator), like in our previous Hello Plu-ts example.

### Template overview

Before we dive in let's get familiar with the starter template.

If we now navigate to `src/contract.ts` we see we have a very simple validator already!

```ts title="src/contract.ts"
import { Address, compile, Credential, pfn, Script, ScriptType, PScriptContext, unit, passert } from "@harmoniclabs/plu-ts";

export const contract = pfn([
    PScriptContext.type
],  unit )
(( { redemeer, tx, purpose } ) => {
    // always succeeds
    return passert.$(true)
});


///////////////////////////////////////////////////////////////////
// ------------------------------------------------------------- //
// ------------------------- utilities ------------------------- //
// ------------------------------------------------------------- //
///////////////////////////////////////////////////////////////////

export const compiledContract = compile( contract );

export const script = new Script(
    ScriptType.PlutusV3,
    compiledContract
);

export const scriptMainnetAddr = new Address(
    "mainnet",
    Credential.script(
        script.hash
    )
);

export const scriptTestnetAddr = new Address(
    "testnet",
    Credential.script(
        script.hash.clone()
    )
);

export default contract;
```

Let's focus only on the contract for now.

As per the latest Plutus V3, this contract expects a mandatory `PScriptContext` to validate a transaction.

`PScriptContext` is a predefined data structure that is passed by the `cardano-node` itself that will run our smart contract.

Finally, the contract is used in `src/index.ts` which is our entry point.

```ts title="src/index.ts"
import { script } from "./contract";

console.log("validator compiled successfully! ðŸŽ‰\n");
console.log(
    JSON.stringify(
        script.toJson(),
        undefined,
        2
    )
);
```

The index just imports `script` from `src/contract.ts` and prints it out in the json form.

If we go back to `src/contract.ts` we see that the script is obtained using the following steps:

1) Compiling the validator with [`compile`](../onchain/API/utilities/compile)

```ts title="src/contract.ts"

// highlight-start
export const compiledContract = compile( contract );
// highlight-end

export const script = new Script(
    ScriptType.PlutusV3,
    compiledContract
);

```
2) Wrapping it in a `Script` that can be used offchain

```ts title="src/contract.ts"

export const compiledContract = compile( contract );

// highlight-start
export const script = new Script(
    ScriptType.PlutusV3,
    compiledContract
);
// highlight-end

```

That is all we need for now.

### Run the template

If we did every step above correctly, we should be able to run
```bash
npm run start
```

and the output should look like:
```
validator compiled successfully! ðŸŽ‰

{
  "type": "PlutusScriptV3",
  "description": "",
  "cborHex": "515001010023259800800c5268b2ae689441"
}
```

Well congratulations ðŸ¥³!

This is your first compiled smart contract ðŸŽ‰!

But we won't stop here for sure!

Let's personalize this smart contract.

## The contract

The contract should succeed if the following two conditions are met:

- the transaction is signed by the `PPubKeyHash` defined in the UTxO datum;
- the transaction lower bound is `Finite` and greater than the datum `deadline` field;

### `VestingDatum`

The first thing we notice is that we need a custom datum.

Let's create a folder `VestingDatum` with `index.ts` file to define the types `beneficiary` and `deadline` in the contract should hold.

Now, modify `src/contract.ts` as follows

```ts title="src/VestingDatum/index.ts"
import { PPubKeyHash, int, pstruct } from "@harmoniclabs/plu-ts";

// modify the Datum as you prefer
const VestingDatum = pstruct({
    VestingDatum: {
        beneficiary: PPubKeyHash.type,
        deadline: int // posix time
    }
});

export default VestingDatum;
```

### Contract signature

There is no change in the contract signature, as all details about the transaction and the purpose of the script within the transaction are embedded within `PScriptContext`.

```ts title="src/contract.ts"
/* imports */

export const contract = pfn([
    // highlight-start
    PScriptContext.type
    // highlight-end
],  unit)
// highlight-start
(( {redeemer, tx, purpose} ) => {
// highlight-end
    /* contract logic */

});

/* other code */

```


### Contract logic

We know for sure that we need 2 conditions. So we will check them separately using two terms- `signedByBeneficiary` and `deadlineReached`.

Now that we have our datum structure, we can use it in the contract definition.

```ts title="src/contract.ts"
/* imports */

export const contract = pfn([
    PScriptContext.type
],  unit)
(( {redeemer, tx, purpose} ) => {
    // highlight-start

    const maybeDatum = plet(
    pmatch(purpose)
    .onSpending(({ datum }) => datum)
    ._(_ => perror(PMaybe(data).type))
  );

     const datum = plet( punsafeConvertType( maybeDatum.unwrap, VestingDatum.type ) )

     const signedByBeneficiary = tx.signatories.some( datum.beneficiary.eq )

    // inlined
    const deadlineReached = plet(
        pmatch( tx.interval.from.bound )
        .onPFinite(({ n: lowerInterval }) =>  
            datum.deadline.ltEq(  ptraceVal( int ).$( lowerInterval ) ) 
        )
        ._( _ => pBool( false ) )
    )

    return passert.$(
        (ptraceIfFalse.$(pdelay(pStr("Error in signedByBeneficiary"))).$(signedByBeneficiary))
        .and( ptraceIfFalse.$(pdelay(pStr("deadline not reached or not specified"))).$( deadlineReached ) )
        .and ( ptraceIfFalse.$(pdelay( pshowInt.$( datum.deadline ).utf8Decoded )).$( deadlineReached )) 
      );

    // highlight-end
});

/* other code */
```

We just initialize them to `pBool( false )` so that if we forget them the contract fails.

But we can already see the structure of the contract this way: we have two conditions, and we want both to be true.

:::tip What's `// inlined` for?

As defined above the terms are inlined **every time that are used**.

This is because we are not using [`plet`](../onchain/Optimizations/plet) to create an actual `plu-ts` variable. Instead we are just holding a reference to that piece of code.

This is not necessarily bad because it helps making the contract more readable (and `plet` would have inlined the term anyway in this particular case for efficiency).

But, it is definitely useful to keep in mind that what we have is **always** inlined with a small comment.

:::

## `signedByBeneficiary`

The first condition for the contract to succeed is:

> the transaction is signed by the `PPubKeyHash` defined in the UTxO datum;

To check that we can use the [`signatories` field](../onchain/API/types/V3/ScriptContext/PTxInfo#signatories) defined in the [`PTxInfo`](../onchain/API/types/V3/ScriptContext/PTxInfo) struct.

We can access the field from the transaction using the dot notation:
```ts
tx.signatories
```

The `signatories` field is a list of `PPubKeyHash`; so we have access to all the [`TermList`](../onchain/stdlib/TermList) methods.

so we can use the [`some` method](../onchain/stdlib/TermList#some) to check that **at least one** element of the list satisfies a given predicate.

In our case:

```ts 
tx.signatories.some( signer => signer.eq( datum.beneficiary ) );
```

Or the equivalent (but slightly more efficient)

```ts 
tx.signatories.some( datum.beneficiary.eq );
```

Here, we would define the `beneficiary` and `deadline` in `datum` of the _spending transaction_(in `src/app/createVesting.ts`).

To use them, extract the `maybeDatum` from `purpose`, and then properly type convert to ultimately get `datum`:
```ts title="src/contract.ts"
const maybeDatum = plet(
    pmatch(purpose)
    .onSpending(({ datum }) => datum)
    ._(_ => perror(PMaybe(data).type))
);

const datum = plet( punsafeConvertType( maybeDatum.unwrap, VestingDatum.type ) )
```


And that's it!

Our `signedByBeneficiary` condition is ready
```ts title="src/contract.ts"
const maybeDatum = plet(
    pmatch(purpose)
    .onSpending(({ datum }) => datum)
    ._(_ => perror(PMaybe(data).type))
);

const datum = plet( punsafeConvertType( maybeDatum.unwrap, VestingDatum.type ) )

const signedByBeneficiary = tx.signatories.some( datum.beneficiary.eq )
```

## `deadlineReached`

Now we can pass to the second condition:

> the transaction lower bound is `Finite` and greater than the datum `deadline` field

:::info but what do we mean by _"transaction lower bound"_?

That is due to how time is handled on-chain.

Handling time on chain is definitely not something simple due to the fact that the underlying system is distributed.

That means that we can't really be 100% sure of the exact moment the script is executed.

To work around this problem, time is represented on chain with a range in which the transaction is considered valid.

If ever the transaction where sent outside of the range, it would be rejected by the node before even executing the script!

So we can at least be sure that the script is executed in the given time range.

:::

We can access the transaction validity time range trough the [`interval` property](../onchain/API/types/V3/ScriptContext/PTxInfo#interval) of the [`PTxInfo`](../onchain/API/types/V3/ScriptContext/PTxInfo) struct.

This is done once again using the dot notation:

```ts 
tx.interval
```

The `interval` type is somewhat complex due to the nested structure; we have

- two initial properties (`from` and `to`) representing the lower and upper bound.
- both the properties then have a `bound` property and an `inclusive` property which is a boolean
(of the two we are only interested in the `bound` one)
- finally the `bound` has 3 constructors as below
```ts 
const PExtended = pstruct({
    PNegInf: {},
    PFinite: { n: int },
    PPosInf: {}
});
```

where `PFinite` is the one we are interested in.

So reaching the `bound` field is the easy part and can be done as follows:
```ts 
tx.interval.from.bound
```

But then we have to use [`pmatch`](../onchain/Control%20Flow/pmatch) to understand what constructor was used.

In particular, we are only interested in the `PFinite` one. So we'll use the underscore (`_`) wildcard to match the other two.

```ts 
pmatch( tx.interval.from.bound )
.onPFinite(({ n: lowerInterval }) => 
    /* deadline condition */
)
._( _ => pBool( false ) )
```

Now that we have access to the transaction lower bound, we can finally check for the deadline to have been passed.

```ts 
datum.deadline.ltEq( lowerInterval ) 
```

Replace `lowerInterval` above with `ptraceVal( int ).$( lowerInterval )` to be able to output the value in `lowerInterval` for debugging purposes.

The final `deadlineReached` condition becomes:

```ts title="src/contract.ts"
// inlined
const deadlineReached = plet(
    pmatch( tx.interval.from.bound )
    .onPFinite(({ n: lowerInterval }) =>
        datum.deadline.ltEq( ptraceVal( int ).$( lowerInterval ) ) 
    )
    ._( _ => pBool( false ) )
)
```

For debugging closely in case the contract fails due to `deadlineReached` condition, and to throw a specific error in that case, we can add `pTrace` to the return statement and modify it as:
```ts title="src/contract.ts"
return passert.$(
        (ptraceIfFalse.$(pdelay(pStr("Error in signedByBenificiary"))).$(signedByBeneficiary))
        .and( ptraceIfFalse.$(pdelay(pStr("deadline not reached or not specified"))).$( deadlineReached ) )
);
```

## Compiling the contract

Our smart contract should now look something like this:

```ts title="src/contract.ts"
export const contract = pfn([
    PScriptContext.type
],  unit)
(( {redeemer, tx, purpose} ) => {

  const maybeDatum = plet(
    pmatch(purpose)
    .onSpending(({ datum }) => datum)
    ._(_ => perror(PMaybe(data).type))
  );

     const datum = plet( punsafeConvertType( maybeDatum.unwrap, VestingDatum.type ) )

     const signedByBeneficiary = tx.signatories.some( datum.beneficiary.eq )

    // inlined
    const deadlineReached = plet(
        pmatch( tx.interval.from.bound )
        .onPFinite(({ n: lowerInterval }) =>
            datum.deadline.ltEq( lowerInterval ) 
        )
        ._( _ => pBool( false ) )
    )

    return passert.$(
        (ptraceIfFalse.$(pdelay(pStr("Error in signedByBenificiary"))).$(signedByBeneficiary))
        .and( ptraceIfFalse.$(pdelay(pStr("deadline not reached or not specified"))).$( deadlineReached ) )
      );

});
```

As we saw in the [Hello plu-ts example project](./Hello_World.mdx), we can compile the contract 
by passing the term to the [`compile`](../onchain/API/utilities/compile) function.

We finally pass the compiled Contract to the `Script` constructor so that we can use it properly.


```ts title="src/contract.ts"
/* contract definition above */

export const compiledContract = compile( contract );

export const script = new Script(
    ScriptType.PlutusV3,
    compiledContract
);

/* some other code */
```

So now running the project using
```bash
npm run start
```

we should see something like this

```
validator compiled successfully! ðŸŽ‰

{
  "type": "PlutusScriptV3",
  "description": "",
  "cborHex": "59022d59022a0101003232323232323223232323259800800c5268b2ae686644b3001002800c5282ae6866016292011c4572726f7220696e207369676e6564427942656e69666963696172790033233009214a04446644b30010028a51800aae68600800426006002466e3cdd71aba10020013323323009235740600400200297ac475c6eb0c8d5d09aba2357446ae88d5d11aba2357446ae88d5d10008010998058a48125646561646c696e65206e6f742072656163686564206f72206e6f7420737065636966696564003298009aba1300735742600e646ae84d5d11aba2357446ae88d5d11aba235744002007001919b89375a600e0066eb4d5d0800c005222232332598009800a400110038acc004c00520028802456600260029002440162cab9a2ae68ab9a1b8735573a0026aae78004dd500209281802991aba135573c6ea8004ca6002646ae84d5d11aba2001003800c00600300191803000c005222222232332598009800a400110038acc004c00520028802456600260029002440162b300130014801a200d1598009800a401110078acc004c005200a8804459573455cd1573455cd1573455cd0dc39aab9d00135573c0026ea801c4c60086ae84004c00c0048d5d09aba2001235573c6ea800488cc00c84008888cc014008c00c004c0088888ca600260080033003001801200c3300400300222259800800c00e2660046ae84004d5d1000aaae7c46460044660040040024600446600400400244b30010018a51899ab9c50024a0ab9a1"
}
```


## Setup Blockfrost API

First and foremost, we need to setup Blockfrost API to use in our app. 

It is enabled by the package `@harmoniclabs/blockfrost-pluts`. In your terminal, do
```bash
npm install @harmoniclabs/blockfrost-pluts
```

Go to https://blockfrost.io/ and create a new project for this example (a free plan is more than enough for now). Make sure to pick `Preprod` as your preferred network. 

Once done, navigate to the Dashboard and copy over PROJECT_ID to setup.

Make sure to not check-in your PROJECT_ID into any versioning systems. Alternatively, you can always use environment variable. Here, please create a `.env` file in your project root and paste the below:
```title=".env"
BLOCKFROST_PROJECT_ID=" <Paste your PROJECT_ID here> "
```

To enable blockfrost within other files, we will later instantiate `blockfrost()` with the PROJECT_ID. 

## Setup TxBuilder

To perform transactions, either through Blockfrost or Emulator, we need to instantiate our `TxBuilder` with the provider of choice.

First, Create file `getProvider.ts` within `src/app/utils`, exporting `getProvider()` with a boolean argument `useEmulator` which decides `createEmulatorProvider` or `createBlockfrostProvider` is to be invoked/setup.
```ts file="src/app/utils/getProvider.ts"
import { BlockfrostPluts } from "@harmoniclabs/blockfrost-pluts";
import { Emulator } from "@harmoniclabs/pluts-emulator";
import * as dotenv from 'dotenv';

// Load environment variables from .env file
dotenv.config();
/**
 * Creates a Blockfrost provider instance
 * @returns BlockfrostPluts provider
 */
function createBlockfrostProvider(): BlockfrostPluts {
    // highlight-start
    // Read projectId from environment variables
    const projectId = process.env.BLOCKFROST_PROJECT_ID;
    //highlight-end

    if (!projectId) {
        throw new Error("PROJECT_ID is not defined in environment variables");
    }
    const provider = new BlockfrostPluts({
        projectId: projectId
    });
    return provider;
}

/**
 * Creates an Emulator provider instance
 * @param initialSettings Optional settings for the emulator
 * @returns Emulator provider
 * TODO: use initializeEmulator from Emulator in the return statement
 */
export function createEmulatorProvider(
    initialSettings?: {
        initialUtxos?: any[],
        debugLevel?: number
    }
): Emulator {
    return new Emulator(
        initialSettings?.initialUtxos || [], 
        undefined, // Use default genesis infos
        undefined, // Use default protocol parameters
        initialSettings?.debugLevel ?? 0 // Default debug level is 0
    );
}

/**
 * Factory function that returns the appropriate provider based on configuration
 * @param useEmulator Whether to use the emulator instead of Blockfrost
 * @param initialSettings Optional settings for the emulator (only used when useEmulator is true)
 * @returns Either BlockfrostPluts or Emulator instance
 */
export function getProvider(
    useEmulator: boolean = false,
    initialSettings?: {
        initialUtxos?: any[],
        debugLevel?: number
    }
): BlockfrostPluts | Emulator {
    if (useEmulator) {
        console.log("Using Emulator");
        return createEmulatorProvider(initialSettings);
    } else {
        console.log("Using Blockfrost - ensure your addresses have been funded with a faucet");
        return createBlockfrostProvider();
    }
}

/**
 * Default provider - uses Blockfrost
 * Maintained for backward compatibility with existing code
 */
export default function blockfrost(): BlockfrostPluts {
    return createBlockfrostProvider();
}
```

Create file `getTxBuilder.ts` within `src/app/utils`, exporting method `getTxBuilder()` which will thus be used to instantiate an instance of `TxBuilder` based on the choice of `provider` passed in, and further used.
```ts title="src/app/utils/getTxBuilder.ts"
import { TxBuilder, defaultMainnetGenesisInfos } from "@harmoniclabs/buildooor";
import { BlockfrostPluts } from "@harmoniclabs/blockfrost-pluts";
import { Emulator } from "@harmoniclabs/pluts-emulator";
import { defaultProtocolParameters } from "@harmoniclabs/plu-ts";

// Cache for the TxBuilder to avoid redundant API calls
let cachedTxBuilder: TxBuilder | undefined = undefined;

/**
 * Creates a TxBuilder with the appropriate protocol parameters and genesis infos
 * Caches the result to avoid redundant API calls
 * @param provider Optional provider (Blockfrost or Emulator) to use for protocol parameters and genesis infos
 * @returns A configured TxBuilder instance
 */
export default async function getTxBuilder(provider?: BlockfrostPluts | Emulator): Promise<TxBuilder> {
  if (!provider) {
    console.warn("No provider passed to getTxBuilder. Using defaults which may not be suitable for mainnet/testnet transactions.");
  }
  // Return cached TxBuilder if available and no provider is specified
  if (cachedTxBuilder && !provider) {
    return cachedTxBuilder;
  }

  if (provider) {
    // Use the provided provider to get protocol parameters and genesis infos
    const [protocolParameters, genesisInfos] = await Promise.all([
      provider.getProtocolParameters(),
      provider.getGenesisInfos()
    ]);

    const txBuilder = new TxBuilder(
      protocolParameters,
      genesisInfos
    );

    // Cache the TxBuilder for future use
    if (!cachedTxBuilder) {
      cachedTxBuilder = txBuilder;
    }

    return txBuilder;
  } else {
    // Use default values if no provider is provided
    if (!cachedTxBuilder) {
      cachedTxBuilder = new TxBuilder(
        defaultProtocolParameters,
        defaultMainnetGenesisInfos
      );
    }
    
    return cachedTxBuilder;
  }
}
```


## Interacting with the contract

We will use the native `npm` script functionality to define some scripts to interact arbitrarily with our new contract.

We can define a new script by adding an entry in the `scripts` field of the `package.json` file that you find in the root of the project.

Right now you should see something like this:
```json title="package.json"
"scripts": {
    "build": "tsc -p ./tsconfig.json && tsc-alias -p ./tsconfig.json",
    "start": "npm run build && node dist/index.js"
},
```

We can add our own scripts by specifying the script name as key and the command to execute as value.

As an example, say we want a better name for the `"start"` script, we could do something like:
```json title="package.json"
"scripts": {
    "build": "tsc -p ./tsconfig.json && tsc-alias -p ./tsconfig.json",
    "start": "npm run build && node dist/index.js",
    // highlight-next-line
    "vesting:compile": "npm run start"
},
```

Now running
```bash
npm run vesting:compile
```
is equivalent to `npm run start`.

To keep the project clean we'll create a new directory under `src` called `app` where all our scripts will be.

```
./vesting-pluts
â””â”€â”€ src
    â””â”€â”€ app
```

## Save the script

Now we can start working with the off-chain part of plu-ts.

Let's start by saving the compiled script to a file when we compile it.

In the `src/index.ts` file add the following:

```ts title="src/index.ts"
// highlight-start
import { existsSync } from "fs";
import { mkdir, writeFile } from "fs/promises";
// highlight-end

/* old code */

// highlight-start
async function main() 
{
    if( !existsSync("./testnet") )
    {
        await mkdir("./testnet");
    }
    await writeFile("./testnet/vesting.plutus.json", JSON.stringify(script.toJson(), undefined, 4))
}
main();
// highlight-end
```

Now running 
```bash
npm run vesting:compile
```

should still print a success result; but it will also create a new `testnet` directory with the file `vesting.plutus.json` in it. 


## Get Addresses and their keys

Depending on if you are working in private or public testnet, 
there are 2 way to get your keys and start creating transactions.

<Tabs>
<TabItem value="Public testnet" label="Public testnet" default>

You can generate your own key pair using `generateKey()` method from Crypto Web API. Read more about this [here](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/generateKey).

Using this, to generate 2 pairs of keys, create a file `genKeys.ts` in the `app` folder that looks like this
```ts title="src/app/utils/genKeys.ts"
import { existsSync } from "fs";
import { Address, Credential, PublicKey, PrivateKey, PubKeyHash } from "@harmoniclabs/plu-ts";
import { config } from "dotenv";
import { mkdir, writeFile } from "fs/promises";
import { blake2b } from 'blakejs';

// Load environment variables
config();

/**
 * Generate Cardano keys and addresses for testing
 * @param numKeys Number of key pairs to generate
 * @param outputDir Directory to store the generated keys and addresses
 */
export async function genKeys(numKeys = 2, outputDir = "./testnet") {
  try {
    console.log(`Generating ${numKeys} key pairs in ${outputDir}`);
    
    // Create output directory if it doesn't exist
    if (!existsSync(outputDir)) {
      console.log(`Creating directory: ${outputDir}`);
      await mkdir(outputDir, { recursive: true });
    }
    
    for (let i = 1; i <= numKeys; i++) {
      console.log(`\nGenerating key pair ${i} of ${numKeys}...`);
      
      try {
        // Generate Ed25519 key pair
        const keyPair = await globalThis.crypto.subtle.generateKey(
          {
            name: "Ed25519",
            namedCurve: "Ed25519"
          },
          true,
          ["sign", "verify"]
        );
        
        // Process public key
        console.log(`  Processing public key ${i}...`);
        const publicKeyArrayBuffer = await globalThis.crypto.subtle.exportKey('raw', keyPair.publicKey);
        const publicKeyUint8Array = new Uint8Array(publicKeyArrayBuffer);
        const publicKey = new PublicKey(publicKeyUint8Array);
        const publicKeyHash = new PubKeyHash(blake2b(publicKeyUint8Array, undefined, 28));
        
        // Create and save public key file
        const pubKeyJsonObj = {
          type: "PaymentVerificationKeyShelley_ed25519",
          description: "Payment Verification Key",
          cborHex: publicKey.toCbor().toString()
        };
        const pubKeyPath = `${outputDir}/payment${i}.vkey`;
        await writeFile(pubKeyPath, JSON.stringify(pubKeyJsonObj, null, 2));
        console.log(`  Public key saved to: ${pubKeyPath}`);
        
        // Process private key
        console.log(`  Processing private key ${i}...`);
        const privateKeyArrayBuffer = await globalThis.crypto.subtle.exportKey('pkcs8', keyPair.privateKey);
        
        // Get the last 32 bytes which is the actual private key in Ed25519
        const privateKeyUint8Array = new Uint8Array(privateKeyArrayBuffer.slice(-32));
        const privateKey = new PrivateKey(privateKeyUint8Array);
        
        // Create and save private key file
        const pvtKeyJsonObj = {
          type: "PaymentSigningKeyShelley_ed25519",
          description: "Payment Signing Key",
          cborHex: privateKey.toCbor().toString()
        };
        const privateKeyPath = `${outputDir}/payment${i}.skey`;
        await writeFile(privateKeyPath, JSON.stringify(pvtKeyJsonObj, null, 2));
        console.log(`  Private key saved to: ${privateKeyPath}`);
        
        // Verify key derivation
        const derivedPublicKey = privateKey.derivePublicKey();
        if (derivedPublicKey.toString() !== publicKey.toString()) {
          throw new Error("Public key derivation from private key failed");
        }
        console.log(`  Verified: Public key correctly derived from private key`);
        
        // Create and save address
        const credential = Credential.keyHash(publicKeyHash);
        const address = new Address("testnet", credential);
        const addressPath = `${outputDir}/address${i}.addr`;
        await writeFile(addressPath, address.toString());
        console.log(`  Address saved to: ${addressPath}`);
        
      } catch (error) {
        console.error(`Error generating key pair ${i}:`, error);
        
      }
    }
    
    console.log(`\nSuccessfully generated ${numKeys} key pairs in ${outputDir}`);
  } catch (error) {
    console.error("Key generation failed:", error);
    process.exit(1);
  }
}

// Allow command line arguments to specify the number of keys
const numKeys = process.argv[2] ? parseInt(process.argv[2]) : 2;

// Execute the function
genKeys(numKeys);
```

Add a new  `npm` script  `vesting:genKeys`
```json title="package.json"
"scripts": {
    // ...
    // highlight-next-line
    "vesting:genKeys": "npm run build:light && node dist/app/utils/genKeys.js"
}
```
so that running
```bash
npm run vesting:genKeys
```
should give us 2 pairs of keys and 2 addresses under the `testnet` folder.

:::info get some funds

Remember to fund the addresses. In this example, make sure to fund **address1** and **address2**; just so that there has been some transactions involving these addresses, and they appear on blockchain and inturn be visible for Blockfrost. Read more about such possible Blockfrost error [here](https://blockfrost.dev/support/cardano#querying-address-returns-404-not-found-but-my-address-is-valid).

You can use the [Cardano Testnet Faucet](https://docs.cardano.org/cardano-testnet/tools/faucet) to get some testnet funds. Just be sure to select `Preprod` testnet.

:::

</TabItem>
<TabItem value="Private testnet" label="Private testnet" >

If you are working in the private testnet then you probably want to use some keys you already have.

Then maybe you can copy those keys in the `testnet` folder we have here.

To do so we can set up a new `setup.ts` script under the `app` folder:

```ts title="src/app/utils/setup.ts"
import { existsSync } from "fs";
import { config } from "dotenv";
import { copyFile, mkdir } from "fs/promises";

config();

async function setup()
{
    const privateTestnet = process.env.PRIVATE_TESTNET_PATH ?? ".";

    const nKeys = 3;

    const promises: Promise<any>[] = [];
    if( !existsSync("./testnet") )
    {
        await mkdir("./testnet");
    }
    
    for( let i = 1; i <= nKeys; i++ )
    {
        promises.push(
            copyFile(`${privateTestnet}/addresses/payment${i}.addr`, `./testnet/address${i}.addr`),
            copyFile(`${privateTestnet}/stake-delegator-keys/payment${i}.vkey`, `./testnet/payment${i}.vkey`),
            copyFile(`${privateTestnet}/stake-delegator-keys/payment${i}.skey`, `./testnet/payment${i}.skey`)
        );
    }

    // wait for all files to be copied
    await Promise.all( promises );
}
setup();
```

And then include a new `npm script` in `package.json`

```json title="package.json"
"scripts": {
    // ...
    // highlight-next-line
    "vesting:setup": "npm run build:light && node dist/app/utils/setup.js"
}
```

so that you can now run

```bash
npm run vesting:setup
```

to have your keys and addresses copied in the `testnet` folder.

</TabItem>
</Tabs>


## Create a Vesting UTxO

Now we can finally start playing around with the vesting contract.

### Read the script

Since we already have our file compiled and saved, it is probably a good idea to read the compiled result instead of re-compiling the contract each time we run the script.

To do so, we can always read the saved `Script`. First we need to read the `vesting.plutus.json` file as string.
```ts
const scriptFile = await readFile("./testnet/vesting.plutus.json", { encoding: "utf-8" });
```
Then, to finally retrieve the `Script` from the `cborHex` in the JSON file:
```ts
const script = Script.fromCbor(JSON.parse(scriptFile).cborHex, ScriptType.PlutusV3)
```
:::info
Make sure to specify `ScriptType.PlutusV3` as second argument to [`Script.fromCbor`](../offchain/cardano-ledger-ts/classes/Script#fromcbor) even though it is optional, because the `defType` arg is by default `Script.PlutusV2` which being legacy.
:::

From here we can generate the script address using the `Address` class (from the offchain of `plu-ts`) and the `Script` as `Credential`.
```ts
const scriptAddr = new Address(
    "testnet",
    new Credential(CredentialType.Script, script.hash)
);
```
:::info Generate Address
Instead of `new Address("testnet", ...)`, we can also do `Address.testnet(...)`. Read more [here](../offchain/cardano-ledger-ts/classes/Address#testnet).
:::

### Get your address

Now, to build and send our transaction we are just missing the sender key, address and the beneficiary public key.

Once again we retrieve them from our saved files using node.js `readFile`.
```ts
const privateKeyFile = await readFile("./testnet/payment1.skey", { encoding: "utf-8" });
const privateKey = PrivateKey.fromCbor( JSON.parse(privateKeyFile).cborHex );

const addr = await readFile("./testnet/address1.addr", { encoding: "utf-8" });
const address = Address.fromString(addr);
    
const publicKeyFile = await readFile("./testnet/payment2.vkey", { encoding: "utf-8" });
const pkh = PublicKey.fromCbor( JSON.parse(publicKeyFile).cborHex ).hash;
```

### Query the address UTxOs

Before we really start building our transaction we need some UTxOs to use as input. We can query the UTxOs available in our address through Emulator/Blockfrost provider.
Make sure to populate both the addresses with some funds.
```ts
const utxos = await provider.addressUtxos( address );
```
:::info
Instead of blindly assigning the first UTxO of the utxos[] as input, let us assure that we use the UTxO that has atleast 15 ada in it just to avoid possible failures.
```ts
const utxo = utxos.find(utxo => utxo.resolved.value.lovelaces >= 15_000_000)!;
``` 
:::

### Build the Transaction

Our transaction will be constructed as follows:
- our UTxO as input
- an output to the contract with an attached `VestingDatum`
- the change going back to the address

which translates to the following code
```ts
const chainTip = await provider.getChainTip();
const deadline = txBuilder.slotToPOSIX(chainTip.slot! + 9); //convert to units POSIX time

let tx = await txBuilder.buildSync({
    inputs: [{ utxo: utxo }],
    collaterals: [utxo],
    outputs: [
        {
            address: scriptAddr,
            value: Value.lovelaces(5_000_000),
            datum: VestingDatum.VestingDatum({
                beneficiary: pBSToData.$(pByteString(pkh.toBuffer())),
                deadline: pIntToData.$(deadline)
            })
        }
    ],
    changeAddress: address
});
```

:::info Have you noticed?

The `datum` attached to the output is generated using on-chain code!

This is done, thanks to plu-ts, being able to evaluate on-chain code and use the result as `Data`.

This way we can use the on-chain types to describe the plutus data off-chain, without the need to use low level `Data` elements! 

:::

### Sign and Submit

Now that we have our transaction, all we need is just to Sign and Submit it.

And guess what? 

This is now extremly easy with `plu-ts` and `Blockfrost`/`Emulator`.

```ts
await tx.signWith( privateKey );

const submittedTx = await provider.submitTx( tx );
```

All we need to do now is to put it all together in a file `createVesting.ts` under the `app` folder.

```ts title="src/app/offchain/createVesting.ts"
import { Address, Credential, PrivateKey, Value, pBSToData, pByteString, pIntToData, CredentialType, PublicKey, Script, ScriptType, IProvider } from "@harmoniclabs/plu-ts";
import VestingDatum from "../../VestingDatum";
import getTxBuilder from "../utils/getTxBuilder";
import { BlockfrostPluts } from "@harmoniclabs/blockfrost-pluts";
import { readFile } from "fs/promises";
import { Emulator } from "@harmoniclabs/pluts-emulator";

/**
 * Creates a vesting contract transaction
 * @param provider The provider to use (Blockfrost or Emulator)
 * @returns The transaction hash
 */
export async function createVesting(provider: BlockfrostPluts | Emulator): Promise<string> {   
    const txBuilder = await getTxBuilder(provider);
     
    const scriptFile = await readFile("./testnet/vesting.plutus.json", { encoding: "utf-8" });
    const script = Script.fromCbor(JSON.parse(scriptFile).cborHex, ScriptType.PlutusV3)
    const scriptAddr = new Address(
        "testnet",
        new Credential(CredentialType.Script, script.hash)
    );
    
    const privateKeyFile = await readFile("./testnet/payment1.skey", { encoding: "utf-8" });
    const privateKey = PrivateKey.fromCbor( JSON.parse(privateKeyFile).cborHex );
    
    const addr = await readFile("./testnet/address1.addr", { encoding: "utf-8" });
    const address = Address.fromString(addr);
    
    const publicKeyFile = await readFile("./testnet/payment2.vkey", { encoding: "utf-8" });
    const pkh = PublicKey.fromCbor( JSON.parse(publicKeyFile).cborHex ).hash;
    const utxos = await provider.addressUtxos(address)
        .catch(e => { throw new Error(`Unable to find UTxOs at ${addr}: ${e.message}`) });
    // At least has 15 ADA
    const utxo = utxos.find(utxo => utxo.resolved.value.lovelaces >= 15_000_000);
    if (!utxo) {
        throw new Error(`No UTxO with more than 15 ADA at address ${address}`);
    }

    const chainTip = await provider.getChainTip();
    const deadline = txBuilder.slotToPOSIX(chainTip.slot! + 9); //convert to units POSIX time

    let tx = await txBuilder.buildSync({
        inputs: [{ utxo: utxo }],
        collaterals: [utxo],
        outputs: [
            {
                address: scriptAddr,
                value: Value.lovelaces(5_000_000),
                datum: VestingDatum.VestingDatum({
                    beneficiary: pBSToData.$(pByteString(pkh.toBuffer())),
                    deadline: pIntToData.$(deadline)
                })
            }
        ],
        changeAddress: address
    });
    
    await tx.signWith(privateKey);

    const submittedTx = await provider.submitTx(tx);
    console.log(`Vesting transaction submitted: ${submittedTx}`);
    console.log(`Vesting deadline set to: ${deadline} - ${new Date(deadline).toISOString()}`);
    
    return submittedTx;
}
```

For the ease of use, let's add a new `npm script` in package.json

```json title="package.json"
"scripts": {
    // ...
    // highlight-next-line
    "vesting:create": "npm run build:light && node dist/app/createVesting.js"
}
```

now running
```bash
npm run vesting:create
```
will generate a new UTxO for the smart contract ready to be spent!

We should also see a similar transaction hash in the console now.
```bash
8b3deb9095898c4d1385269f0af00febaa547e4b4365978d073519caa52f791e
```

## Spend the locked UTxO

### Get all you need

You know the process now:

- read the script
- build the script address
- read address and keys
- query UTxO

These are the steps needed before we can start to build the transaction and are often very similar.

```ts
import { Address, DataI, Credential, PrivateKey, CredentialType, Script, DataConstr, DataB, PublicKey, defaultPreprodGenesisInfos, ScriptType, IProvider, Machine, UPLCProgram, parseUPLC } from "@harmoniclabs/plu-ts";
import getTxBuilder from "../utils/getTxBuilder";
import { BlockfrostPluts } from "@harmoniclabs/blockfrost-pluts";
import { readFile } from "fs/promises";
import { Emulator } from "@harmoniclabs/pluts-emulator";

/**
 * Claims funds from a vesting contract
 * @param provider The provider to use (Blockfrost or Emulator)
 * @returns The transaction hash
 */
export async function claimVesting(provider: BlockfrostPluts | Emulator): Promise<string> {
    const txBuilder = await getTxBuilder(provider);

    const scriptFile = await readFile("./testnet/vesting.plutus.json", { encoding: "utf-8" });
    const script = Script.fromCbor(JSON.parse(scriptFile).cborHex, ScriptType.PlutusV3)

    const scriptAddr = new Address(
        "testnet",
        new Credential(CredentialType.Script, script.hash)
    );

    const privateKeyFile = await readFile("./testnet/payment2.skey", { encoding: "utf-8" });
    const privateKey = PrivateKey.fromCbor(JSON.parse(privateKeyFile).cborHex);

    const pubKey = privateKey.derivePublicKey();

    const addr = await readFile("./testnet/address2.addr", { encoding: "utf-8" });
    const address = Address.fromString(addr);

    const publicKeyFile = await readFile("./testnet/payment2.vkey", { encoding: "utf-8" });
    const pkh = PublicKey.fromCbor(JSON.parse(publicKeyFile).cborHex).hash;


    const utxos = await provider.addressUtxos(address)
        .catch(e => { throw new Error(`Unable to find UTxOs at ${addr}: ${e.message}`) });

    // At least has 15 ADA
    let utxo; 
    utxos.forEach(item => { 
        if (item.resolved.value.lovelaces >= 15_000_000) {
            utxo = item;
        }
    });
    if (!utxo) {
        throw new Error("No UTxO with more than 15 ADA");
    }

    // Use the following lines if you want to use a specific collateral UTxO
    // Find a smaller UTxO for collateral
    let collateralUtxo;
    utxos.forEach(item => {
        const lovelaces = item.resolved.value.lovelaces
        if (lovelaces >= 1_00_000 && lovelaces <= 5_000_000) {
            collateralUtxo = item;
        }
    });
    if (!collateralUtxo) {
        throw new Error("No small UTxO found for collateral. Use a UTxO with at least 0.1 ADA but less than 5 ADA");
    }

    /* ...to be continued */
}
```

Query the `scriptUtxos`, to specifically use the `utxo` that matches `publicKeyHash` within its datum.
```ts
    const scriptUtxos = await provider.addressUtxos(scriptAddr)
        .catch(e => { throw new Error(`Unable to find UTxOs at script address: ${e.message}`) });
        
    // Find the script UTxO that matches our public key hash
    const scriptUtxo = scriptUtxos.find(utxo => {
        if (utxo.resolved.datum instanceof DataConstr) { 
            const pkhData = utxo.resolved.datum.fields[0]; 
            if (pkhData instanceof DataB) {
                return pkh.toString() === Buffer.from(pkhData.bytes.toBuffer()).toString("hex");
            }
        }
        return false; 
    });
    
    if (!scriptUtxo) {
        throw new Error("No script UTxO found for the pkh");
    }
```

:::info Use the beneficiary keys!

Note that we are reading the keys (both private and public) of the beneficiary, we had set in the previous script, here.

If we used the other keys the script would fail each time!

:::

### Build the Transaciton

This time our transaction will be formed as follows

- one of our utxos
- the UTxO locked at the script address (with corresponding `Script` in order to validate the spending of it)
- the public key hash as `requiredSigners` element so that it is aviable in `ctx.tx.signatories`
- our UTxO as collateral input that MUST be present every time a script is included in the transaciton
- the `invalidBefore` field corresponding to the last slot heigth (otherwise the transaciton interval is negative infinite and the contract will fail!)

Of the above, the last one sounds courious... How do we get the last slot of the blockchain/emulator?

Blockfrost does helps us with that! Emulator is also built mimicing Blockfrost. So, we just have to do,
```ts
(await provider.getChainTip()).slot!
```

Before building the transaction, we have to ensure the txBuilder genesisInfo is set to its Preprod defaults, by:
```ts
txBuilder.setGenesisInfos( defaultPreprodGenesisInfos )
```

Now the Transaction can be built as follows:

```ts
let tx = await txBuilder.buildSync({
        inputs: [
            { utxo: utxo }, // Regular input
            {
                utxo: scriptUtxo, // Script input
                inputScript: {
                    script: script, // Plutus script
                    datum: "inline", // Datum associated with the script UTxO
                    redeemer: new DataI(0) // Redeemer to unlock the script UTxO
                }
            }
        ],
        requiredSigners: [pkh],
        collaterals: [collateralUtxo],
        changeAddress: address,
        invalidBefore: invalidBefore
    });
```

Finally, after we add the Sign and Submit code as done previously:
```ts
await tx.signWith( privateKey );

const submittedTx = await provide.submitTx( tx )
```

We can put all together in a `claimVesting.ts` file in the `app` folder:

```ts title="src/app/offchain/claimVesting.ts"
import { Address, DataI, Credential, PrivateKey, CredentialType, Script, DataConstr, DataB, PublicKey, defaultPreprodGenesisInfos, ScriptType, IProvider, Machine, UPLCProgram, parseUPLC } from "@harmoniclabs/plu-ts";
import getTxBuilder from "../utils/getTxBuilder";
import { BlockfrostPluts } from "@harmoniclabs/blockfrost-pluts";
import { readFile } from "fs/promises";
import { Emulator } from "@harmoniclabs/pluts-emulator";

/**
 * Claims funds from a vesting contract
 * @param provider The provider to use (Blockfrost or Emulator)
 * @returns The transaction hash
 */
export async function claimVesting(provider: BlockfrostPluts | Emulator): Promise<string> {
    const txBuilder = await getTxBuilder(provider);

    const scriptFile = await readFile("./testnet/vesting.plutus.json", { encoding: "utf-8" });
    const script = Script.fromCbor(JSON.parse(scriptFile).cborHex, ScriptType.PlutusV3)

    const scriptAddr = new Address(
        "testnet",
        new Credential(CredentialType.Script, script.hash)
    );

    const privateKeyFile = await readFile("./testnet/payment2.skey", { encoding: "utf-8" });
    const privateKey = PrivateKey.fromCbor(JSON.parse(privateKeyFile).cborHex);

    const pubKey = privateKey.derivePublicKey();

    const addr = await readFile("./testnet/address2.addr", { encoding: "utf-8" });
    const address = Address.fromString(addr);

    const publicKeyFile = await readFile("./testnet/payment2.vkey", { encoding: "utf-8" });
    const pkh = PublicKey.fromCbor(JSON.parse(publicKeyFile).cborHex).hash;


    const utxos = await provider.addressUtxos(address)
        .catch(e => { throw new Error(`Unable to find UTxOs at ${addr}: ${e.message}`) });

    // At least has 15 ADA
    let utxo; 
    utxos.forEach(item => { 
        if (item.resolved.value.lovelaces >= 15_000_000) {
            utxo = item;
        }
    });
    if (!utxo) {
        throw new Error("No UTxO with more than 15 ADA");
    }

    // Use the following lines if you want to use a specific collateral UTxO
    // Find a smaller UTxO for collateral
    let collateralUtxo;
    utxos.forEach(item => {
        const lovelaces = item.resolved.value.lovelaces
        if (lovelaces >= 1_00_000 && lovelaces <= 5_000_000) {
            collateralUtxo = item;
        }
    });
    if (!collateralUtxo) {
        throw new Error("No small UTxO found for collateral. Use a UTxO with at least 0.1 ADA but less than 5 ADA");
    }


    const scriptUtxos = await provider.addressUtxos(scriptAddr)
        .catch(e => { throw new Error(`Unable to find UTxOs at script address: ${e.message}`) });
        
    // Find the script UTxO that matches our public key hash
    const scriptUtxo = scriptUtxos.find(utxo => {
        if (utxo.resolved.datum instanceof DataConstr) { 
            const pkhData = utxo.resolved.datum.fields[0]; 
            if (pkhData instanceof DataB) {
                return pkh.toString() === Buffer.from(pkhData.bytes.toBuffer()).toString("hex");
            }
        }
        return false; 
    });
    
    if (!scriptUtxo) {
        throw new Error("No script UTxO found for the pkh");
    }
     
    txBuilder.setGenesisInfos(defaultPreprodGenesisInfos);

    if (Buffer.from(script.hash.toBuffer()).toString("hex") !== Buffer.from(scriptAddr.paymentCreds.hash.toBuffer()).toString("hex")) {
        throw new Error("Script hash and script address hash do not match");
    }

    // Get chain tip to set correct validity timeframe
    const chainTip = await provider.getChainTip();
    const invalidBefore = chainTip.slot!;
    console.log("Claim Invalid Before : " + invalidBefore)
    
        let tx = await txBuilder.buildSync({
            inputs: [
                { utxo: utxo }, // Regular input
                {
                    utxo: scriptUtxo, // Script input
                    inputScript: {
                        script: script, // Plutus script
                        datum: "inline", // Datum associated with the script UTxO
                        redeemer: new DataI(0) // Redeemer to unlock the script UTxO
                    }
                }
            ],
            requiredSigners: [pkh],
            collaterals: [collateralUtxo],
            changeAddress: address,
            invalidBefore: invalidBefore
        });

    await tx.signWith(privateKey);
    
    const submittedTx = await provider.submitTx(tx);
    
    return submittedTx;
}
```

After adding a new `npm script` in package.json

```json title="package.json"
"scripts": {
    // ...
    // highlight-next-line
    "vesting:claim": "npm run build:light && node dist/app/offchain/claimVesting.js"
}
```

to try claim the UTxO, we can run:
```bash
npm run vesting:claim
```

:::caution Wait some seconds

If you run the script shortly after you created and locked the UTxO the script will fail!

In the previous script, we had set a locking period of 10 seconds.

So you just have to have a little patience :)

:::

If everything goes correctly, the program should terminate without errors. It will definitely console back the transaction hash in the terminal.

## Bonus: Return the tADA

If you were in public testnet remember to return the tADA to the faucet.

For this, you can add the following file and script to automate everything.

```ts title="src/app/offchain/returnFaucet.ts"
import { BlockfrostPluts } from "@harmoniclabs/blockfrost-pluts";
import { Address, ITxBuildInput, IUTxO, PrivateKey } from "@harmoniclabs/plu-ts";
import { readFile, readdir} from "fs/promises";
import { Emulator } from "@harmoniclabs/pluts-emulator";
// import { blockfrost } from "../utils/getProvider";
import getTxBuilder from "../utils/getTxBuilder";

// Faucet return address (preprod)
const faucetAddress = "addr_test1qqr585tvlc7ylnqvz8pyqwauzrdu0mxag3m7q56grgmgu7sxu2hyfhlkwuxupa9d5085eunq2qywy7hvmvej456flknswgndm3";

/**
 * Finds all key pairs in the specified directory
 * @param keyDir Directory containing the keys and addresses
 * @returns Array of key indices found
 */
async function findKeyPairs(keyDir: string): Promise<number[]> {
    try {
      // Read all files in the directory
      const files = await readdir(keyDir);
      
      // Find all files matching the pattern "payment*.skey"
      const skeyFiles = files.filter(file => file.match(/^payment(\d+)\.skey$/));
      
      // Extract the indices from the filenames
      const indices = skeyFiles.map(file => {
        const match = file.match(/^payment(\d+)\.skey$/);
        return match ? parseInt(match[1]) : -1;
      }).filter(index => index > 0);
      
      return indices.sort((a, b) => a - b);
    } catch (error) {
      console.error(`Error scanning directory ${keyDir}:`, error);
      return [];
    }
  }

/**
 * Returns all funds from generated addresses back to the faucet
 * @param numKeys Number of key pairs to process (default: 2)
 * @param keyDir Directory containing the keys and addresses (default: "./testnet")
 * @param useEmulator Whether to use the emulator instead of Blockfrost (default: false)
 * @returns Transaction hash of the submitted transaction
 */
export async function returnFaucet(provider: BlockfrostPluts | Emulator, keyDir = "./testnet", useEmulator = false): Promise<string> {
    try {
        const keyIndices = await findKeyPairs(keyDir);

        if (keyIndices.length === 0) {
            console.log("No key pairs found in the specified directory.");
            return "";
        }
        
        const utxos: ITxBuildInput[] = [];
        const pvtKeys: PrivateKey[] = [];

        for (const keyIndex of keyIndices) {
            try {
                const pvtKeyPath = `${keyDir}/payment${keyIndex}.skey`;
                const pvtKeyFile = await readFile(pvtKeyPath, { encoding: "utf-8" });
                const pvtKey = PrivateKey.fromCbor(JSON.parse(pvtKeyFile).cborHex);

                // Load address
                const addrPath = `${keyDir}/address${keyIndex}.addr`;
                const addrFile = await readFile(addrPath, { encoding: "utf-8" });
                const addr = Address.fromString(addrFile);

                // Get UTxOs for the address
                const addrUtxos = await provider.addressUtxos(addr);

                if (addrUtxos.length === 0) {
                    console.log(`No UTxOs found for address ${addr}`);
                    continue;
                }

                const totalLovelaces = addrUtxos.reduce((sum, utxo) => sum + utxo.resolved.value.lovelaces, 0n);
                
                // Cannot send less than 1 ADA
                if (totalLovelaces < 1_000_000) {
                    console.log(`Not enough lovelaces at address ${addr}. Skipping...`);
                    continue;
                }
                
                // Add UTxOs to the list
                addrUtxos.forEach(utxo => utxos.push({ utxo }));

                // Add private key to the list
                pvtKeys.push(pvtKey);

            } catch (error) {
                console.error(`Error processing key pair ${keyIndex}:`, error);
                // Continue to the next key pair
                continue;
            }
        }

        // Check if we have any UTxOs to process
        if (utxos.length === 0) {
            console.log("No UTxOs found for the specified key pairs.");
            return "";
        }

        // Building the transaction
        const txBuilder = await getTxBuilder(provider);

        let returnTx = await txBuilder.buildSync({
            inputs: utxos,
            changeAddress: faucetAddress,
        });

        // Sign the transaction with all private keys
        for (const privateKey of pvtKeys) {
            await returnTx.signWith(privateKey);
        }

        // Submit the transaction
        const submittedTx = await provider.submitTx(returnTx);
        return submittedTx;
    } catch (error) {
        console.error("Error returning funds to faucet:", error);
        throw error;
    }
}


// Parse command line arguments
function parseArgs() {
    const args = process.argv.slice(2);
    let keyDir = "./testnet";
    let useEmulator = false;
    
    for (let i = 0; i < args.length; i++) {
      if (args[i] === '--dir' || args[i] === '-d') {
        if (i + 1 < args.length) {
          keyDir = args[i + 1];
          i++;
        }
      } else if (args[i] === '--emulator' || args[i] === '-e') {
        useEmulator = true;
      } else if (!args[i].startsWith('-') && i === 0) {
        keyDir = args[i];
      }
    }
    
    return { keyDir, useEmulator };
  }

```
```json title="package.json"
"scripts": {
    // ...
    // highlight-next-line
    "vesting:returnFaucet": "npm run build:light && node dist/app/offchain/returnFaucet.js"
}
```
```bash
npm run vesting:returnFaucet
```

## Test with Emulator

The above details mainly covered running the vesting example with Blockfrost. When trying to test the example in the Plu-ts Emulator environment locally, we need to add a few more details to facilitate this.

First, let's add a script file `testE2E.ts` to `src/test/`. See [`main/src/test/testE2E.ts`](https://github.com/HarmonicLabs/vesting-pluts/blob/main/src/test/testE2E.ts) for the contents of the file.
See [Vesting - README.md](https://github.com/HarmonicLabs/vesting-pluts/blob/main/README.md#run) for more details.

Now, add an npm run script for emulator debugging
```json title="package.json"
"scripts": {
    // ...
    // highlight-next-line
    "test:emulator": "npm run build:light && node dist/test/testE2E.js --emulator"
}
```

Run the example as per the Vesting-README.md. 

You should be able to see something similar to below in your terminal.
```
$ npm run test:emulator

> vesting-pluts@0.0.1 test:emulator
> npm run build:light && node dist/test/testE2E.js --emulator


> vesting-pluts@0.0.1 build:light
> tsc -p ./tsconfig.json && tsc-alias -p ./tsconfig.json

Running vesting E2E test using Emulator

=== Initial Emulator State ===
=== Ledger State ===
Block Height: 0
Current Slot: 4492800
Current Time: 2020-07-29T21:44:51.000Z

=== UTxOs (3) ===
Address: addr_test1vqkrxf2jhqzhwrl4q2ncqvdul9t5c7m6gzh9mlpjerv2v8sfgqf04
  UTxOs: 1
  Total Balance: 15000000 lovelaces
Address: addr_test1vpd6q8ltmxhdzq4u0qnca6jselr8z0jr2paygk6pst58udsgyg7wp
  UTxOs: 2
  Total Balance: 20000000 lovelaces

=== Mempool ===
Mempool is empty.

=== End of Ledger State ===


=== Step 1: Creating vesting contract ===
[Emulator Debug level 2]: Resolving UTxOs for address: addr_test1vqkrxf2jhqzhwrl4q2ncqvdul9t5c7m6gzh9mlpjerv2v8sfgqf04
[Emulator Debug level 2]: Found 1 UTxO references for address: addr_test1vqkrxf2jhqzhwrl4q2ncqvdul9t5c7m6gzh9mlpjerv2v8sfgqf04
[Emulator Debug level 2]: Resolved 1 UTxOs for address addr_test1vqkrxf2jhqzhwrl4q2ncqvdul9t5c7m6gzh9mlpjerv2v8sfgqf04:
[Emulator Debug level 2]:   UTxO: 0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef#0, Value: 15000000 lovelaces
[Emulator Debug level 1]: Submitting transaction 40a8ceaa364e49730d0cebce43fc8edcd2648b1eacfe2cca26a700b2e1c31f57
[Emulator Debug level 1]: Transaction body: {"inputs":[{"utxoRef":{"id":"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef","index":0},"resolved":{"address":"addr_test1vqkrxf2jhqzhwrl4q2ncqvdul9t5c7m6gzh9mlpjerv2v8sfgqf04","value":{"":{"":"15000000"}}}}],"outputs":[{"address":"addr_test1wrp7w2ltm6sv2ptk8eq47hct6lk27k8rxcfdyx7z9mekh5sqxvxc4","value":{"":{"":"5000000"}},"datum":{"constr":0,"fields":[{"bytes":"5ba01febd9aed102bc78278eea50cfc6713e43507a445b4182e87e36"},{"int":"1596059100000"}]}},{"address":"addr_test1vqkrxf2jhqzhwrl4q2ncqvdul9t5c7m6gzh9mlpjerv2v8sfgqf04","value":{"":{"":"9830275"}}}],"fee":"169725","collateralInputs":[{"utxoRef":{"id":"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef","index":0},"resolved":{"address":"addr_test1vqkrxf2jhqzhwrl4q2ncqvdul9t5c7m6gzh9mlpjerv2v8sfgqf04","value":{"":{"":"15000000"}}}}],"network":"testnet"}
[Emulator Debug level 2]: Validating transaction: 40a8ceaa364e49730d0cebce43fc8edcd2648b1eacfe2cca26a700b2e1c31f57
[Emulator Debug level 2]: Transaction 40a8ceaa364e49730d0cebce43fc8edcd2648b1eacfe2cca26a700b2e1c31f57 is valid
[Emulator Debug level 1]: Transaction 40a8ceaa364e49730d0cebce43fc8edcd2648b1eacfe2cca26a700b2e1c31f57 has passed phase-1 validation. Proceeding for phase-2.
[Emulator Debug level 1]: Phase2 validation result:  
[Emulator Debug level 1]: Transaction 40a8ceaa364e49730d0cebce43fc8edcd2648b1eacfe2cca26a700b2e1c31f57 is valid: Adding to mempool, length: 1.
Vesting transaction submitted: 40a8ceaa364e49730d0cebce43fc8edcd2648b1eacfe2cca26a700b2e1c31f57
Vesting deadline set to: 1596059100000 - 2020-07-29T21:45:00.000Z
Vesting contract created with transaction: 40a8ceaa364e49730d0cebce43fc8edcd2648b1eacfe2cca26a700b2e1c31f57

=== Step 2: Waiting for confirmation ===
Advancing emulator by 3 blocks for confirmation
[Emulator Debug level 1]: Advancing to block number 3 (slot 4492860). Time: 2020-07-29T21:44:54.000Z
[Emulator Debug level 2]: Processing block 1 of 3
[Emulator Debug level 1]: Updating ledger, mempool length: 1
[Emulator Debug level 2]: Max block body size: 73728
[Emulator Debug level 2]: Processing transaction of size 322.
[Emulator Debug level 1]: Processing transaction 40a8ceaa364e49730d0cebce43fc8edcd2648b1eacfe2cca26a700b2e1c31f57
[Emulator Debug level 2]: Validating transaction: 40a8ceaa364e49730d0cebce43fc8edcd2648b1eacfe2cca26a700b2e1c31f57
[Emulator Debug level 2]: Transaction 40a8ceaa364e49730d0cebce43fc8edcd2648b1eacfe2cca26a700b2e1c31f57 is valid
[Emulator Debug level 2]: Removing input 0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef#0 from ledger
[Emulator Debug level 2]: Adding output 40a8ceaa364e49730d0cebce43fc8edcd2648b1eacfe2cca26a700b2e1c31f57#0 to ledger
[Emulator Debug level 2]: Adding output 40a8ceaa364e49730d0cebce43fc8edcd2648b1eacfe2cca26a700b2e1c31f57#1 to ledger
[Emulator Debug level 1]: Updated UTxO Set: [object Map]
[Emulator Debug level 2]: Processed transaction 40a8ceaa364e49730d0cebce43fc8edcd2648b1eacfe2cca26a700b2e1c31f57, size 322 bytes, block: 322/73728 bytes.
[Emulator Debug level 1]: Block processing complete. 1 transactions processed for 322 bytes.
[Emulator Debug level 2]: Fast forwarding remaning 2 blocks as mempool is empty

=== Step 3: Waiting for deadline to pass ===
Advancing emulator by 6 blocks to pass deadline
[Emulator Debug level 1]: Advancing to block number 9 (slot 4492980). Time: 2020-07-29T21:45:00.000Z
[Emulator Debug level 2]: Fast forwarding remaning 6 blocks as mempool is empty

=== Step 4: Claiming vested funds ===
[Emulator Debug level 2]: Resolving UTxOs for address: addr_test1vpd6q8ltmxhdzq4u0qnca6jselr8z0jr2paygk6pst58udsgyg7wp
[Emulator Debug level 2]: Found 2 UTxO references for address: addr_test1vpd6q8ltmxhdzq4u0qnca6jselr8z0jr2paygk6pst58udsgyg7wp
[Emulator Debug level 2]: Resolved 2 UTxOs for address addr_test1vpd6q8ltmxhdzq4u0qnca6jselr8z0jr2paygk6pst58udsgyg7wp:
[Emulator Debug level 2]:   UTxO: 123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0#0, Value: 15000000 lovelaces
[Emulator Debug level 2]:   UTxO: 23456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01#0, Value: 5000000 lovelaces
[Emulator Debug level 2]: Resolving UTxOs for address: addr_test1wrp7w2ltm6sv2ptk8eq47hct6lk27k8rxcfdyx7z9mekh5sqxvxc4
[Emulator Debug level 2]: Found 1 UTxO references for address: addr_test1wrp7w2ltm6sv2ptk8eq47hct6lk27k8rxcfdyx7z9mekh5sqxvxc4
[Emulator Debug level 2]: Resolved 1 UTxOs for address addr_test1wrp7w2ltm6sv2ptk8eq47hct6lk27k8rxcfdyx7z9mekh5sqxvxc4:
[Emulator Debug level 2]:   UTxO: 40a8ceaa364e49730d0cebce43fc8edcd2648b1eacfe2cca26a700b2e1c31f57#0, Value: 5000000 lovelaces
Claim Invalid Before : 4492860
[Emulator Debug level 1]: Submitting transaction 3554c9b4eee213f48b483d724053c504e596619074fb6e31b3886c05e366d68a
[Emulator Debug level 1]: Transaction body: {"inputs":[{"utxoRef":{"id":"123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0","index":0},"resolved":{"address":"addr_test1vpd6q8ltmxhdzq4u0qnca6jselr8z0jr2paygk6pst58udsgyg7wp","value":{"":{"":"15000000"}}}},{"utxoRef":{"id":"40a8ceaa364e49730d0cebce43fc8edcd2648b1eacfe2cca26a700b2e1c31f57","index":0},"resolved":{"address":"addr_test1wrp7w2ltm6sv2ptk8eq47hct6lk27k8rxcfdyx7z9mekh5sqxvxc4","value":{"":{"":"5000000"}},"datum":{"constr":0,"fields":[{"bytes":"5ba01febd9aed102bc78278eea50cfc6713e43507a445b4182e87e36"},{"int":"1596059100000"}]}}}],"outputs":[{"address":"addr_test1vpd6q8ltmxhdzq4u0qnca6jselr8z0jr2paygk6pst58udsgyg7wp","value":{"":{"":"19778906"}}}],"fee":"221094","validityIntervalStart":"4492860","scriptDataHash":"ff3ce028b166b25e4b6c43de8e66bc6698f8b466941f2a1d4d723c6849cadb97","collateralInputs":[{"utxoRef":{"id":"23456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01","index":0},"resolved":{"address":"addr_test1vpd6q8ltmxhdzq4u0qnca6jselr8z0jr2paygk6pst58udsgyg7wp","value":{"":{"":"5000000"}}}}],"requiredSigners":["5ba01febd9aed102bc78278eea50cfc6713e43507a445b4182e87e36"],"network":"testnet"}
[Emulator Debug level 2]: Validating transaction: 3554c9b4eee213f48b483d724053c504e596619074fb6e31b3886c05e366d68a
[Emulator Debug level 2]: Transaction 3554c9b4eee213f48b483d724053c504e596619074fb6e31b3886c05e366d68a is valid
[Emulator Debug level 1]: Transaction 3554c9b4eee213f48b483d724053c504e596619074fb6e31b3886c05e366d68a has passed phase-1 validation. Proceeding for phase-2.
[Emulator Debug level 1]: Phase2 validation result: [object Object] 
[Emulator Debug level 1]: Transaction 3554c9b4eee213f48b483d724053c504e596619074fb6e31b3886c05e366d68a is valid: Adding to mempool, length: 1.
Vested funds claimed with transaction: 3554c9b4eee213f48b483d724053c504e596619074fb6e31b3886c05e366d68a

=== Step 5: Waiting for final confirmation ===
Advancing emulator by 1 block for confirmation
[Emulator Debug level 1]: Advancing to block number 10 (slot 4493000). Time: 2020-07-29T21:45:01.000Z
[Emulator Debug level 2]: Processing block 1 of 1
[Emulator Debug level 1]: Updating ledger, mempool length: 1
[Emulator Debug level 2]: Max block body size: 73728
[Emulator Debug level 2]: Processing transaction of size 1264.
[Emulator Debug level 1]: Processing transaction 3554c9b4eee213f48b483d724053c504e596619074fb6e31b3886c05e366d68a
[Emulator Debug level 2]: Validating transaction: 3554c9b4eee213f48b483d724053c504e596619074fb6e31b3886c05e366d68a
[Emulator Debug level 2]: Transaction 3554c9b4eee213f48b483d724053c504e596619074fb6e31b3886c05e366d68a is valid
[Emulator Debug level 2]: Removing input 123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0#0 from ledger
[Emulator Debug level 2]: Removing input 40a8ceaa364e49730d0cebce43fc8edcd2648b1eacfe2cca26a700b2e1c31f57#0 from ledger
[Emulator Debug level 2]: Adding output 3554c9b4eee213f48b483d724053c504e596619074fb6e31b3886c05e366d68a#0 to ledger
[Emulator Debug level 1]: Updated UTxO Set: [object Map]
[Emulator Debug level 2]: Processed transaction 3554c9b4eee213f48b483d724053c504e596619074fb6e31b3886c05e366d68a, size 1264 bytes, block: 1264/73728 bytes.
[Emulator Debug level 1]: Block processing complete. 1 transactions processed for 1264 bytes.

=== Final Emulator State ===
=== Ledger State ===
Block Height: 10
Current Slot: 4493000
Current Time: 2020-07-29T21:45:01.000Z

=== UTxOs (3) ===
Address: addr_test1vpd6q8ltmxhdzq4u0qnca6jselr8z0jr2paygk6pst58udsgyg7wp
  UTxOs: 2
  Total Balance: 24778906 lovelaces
Address: addr_test1vqkrxf2jhqzhwrl4q2ncqvdul9t5c7m6gzh9mlpjerv2v8sfgqf04
  UTxOs: 1
  Total Balance: 9830275 lovelaces

=== Mempool ===
Mempool is empty.

=== End of Ledger State ===


=== Final Verification ===
[Emulator Debug level 2]: Resolving UTxOs for address: addr_test1vqkrxf2jhqzhwrl4q2ncqvdul9t5c7m6gzh9mlpjerv2v8sfgqf04
[Emulator Debug level 2]: Found 1 UTxO references for address: addr_test1vqkrxf2jhqzhwrl4q2ncqvdul9t5c7m6gzh9mlpjerv2v8sfgqf04
[Emulator Debug level 2]: Resolved 1 UTxOs for address addr_test1vqkrxf2jhqzhwrl4q2ncqvdul9t5c7m6gzh9mlpjerv2v8sfgqf04:
[Emulator Debug level 2]:   UTxO: 40a8ceaa364e49730d0cebce43fc8edcd2648b1eacfe2cca26a700b2e1c31f57#1, Value: 9830275 lovelaces
[Emulator Debug level 2]: Resolving UTxOs for address: addr_test1vpd6q8ltmxhdzq4u0qnca6jselr8z0jr2paygk6pst58udsgyg7wp
[Emulator Debug level 2]: Found 2 UTxO references for address: addr_test1vpd6q8ltmxhdzq4u0qnca6jselr8z0jr2paygk6pst58udsgyg7wp
[Emulator Debug level 2]: Resolved 2 UTxOs for address addr_test1vpd6q8ltmxhdzq4u0qnca6jselr8z0jr2paygk6pst58udsgyg7wp:
[Emulator Debug level 2]:   UTxO: 23456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01#0, Value: 5000000 lovelaces
[Emulator Debug level 2]:   UTxO: 3554c9b4eee213f48b483d724053c504e596619074fb6e31b3886c05e366d68a#0, Value: 19778906 lovelaces
Address 1 balance: 9830275 lovelaces
Address 2 balance: 24778906 lovelaces
Verification complete

=== Test Completed Successfully ===
Test completed successfully
```
